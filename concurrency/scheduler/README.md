## Планировщик ОС
У каждого ядра есть системные треды, которые могут быть executing, runnable или waiting.
Каждый тред стоит в очереди и ждет выполнения своей задачи. Операции перевода треда из одного состояние в другое называется переключением контекста.
*Переключением контекста занимается планировщик ОС.*

Переключение контекста является случайным. Разработчик не может предсказать в какой момент переключится контекст и как то повлиять на него. Такое поведение называется вытесняющей многозадачностью.

В языке го многозадачность кооперативная(но с небольшими элементами вытесняющей).

Чем больше тредов - тем хуже. Потому что чем больше тредов, тем больше операций переключения контекста и тем меньше времени остается на выполнение задачи.

## Планировщик го
Планировщик го управляет абстракциями над системным тредом - легковесными горутинами.
Горутины распологаются в UserSpace, треды в KernelSpace, т.е треды управляются процессором, а горутины планировщиком го.

Горутины вешаются на тред и могут быть в трех состояниях: executing, runnable или waiting.
Треды выполняются на ядрах, горутины на тредах.

## GMP model
G - горутина
M - машина(то, на чем выполняется горутина, в нашем случае тред)(на самом деле не совсем так, это абстракция которая есть в языке)
P -  процессор(не путать с процессором компьютера и планировщиком). Процессор просто помешает и вытаскивает горутины в машину и из нее

## Модель 1:1
При создании горутины под нее создается тред. Когда горутина отработала, уничтожаем ее и так же уничтожаем ее тред.

## Модель 1:N
Существует один тред, на него вешаем N горутин

## Модель N:M
При создании горутины мы вешаем ее на свободный тред из пула свободных тредов.
Причем, перед тем, как выдать тред горутине, мы проверяем лимит тредов.
Если лимит тредов превышен и свободных нет, горутина помещается в GRQ - Global Run Queue.
Чтобы несколько процессоров не пытались повесить одну и туже горутину на разные машины, для каждого процессора предусмотрена очередь LRQ - Local Run Queue.

1/61 GRQ - Процессор обращается к GRQ 1 раз на 61 обращение в LRQ
Так же процессор может украсть горутины у слишком занятого треда и перенести их на более свободный - это называется work stealing.


## Handoff
Если в какой то момент Executing горутина делает syscall, то блокируется весь тред.
Чтобы он не простаивал, создается новый тред и процессор заблокированного треда привязывается к новому треду. Этот механизм называется Handoff 

## Sysmon
Когда выполняется syscall, нужно понять будет он коротким или длинным, чтобы не наплодить лишний тредов. Поэтому вов ремя каждого syscall, System monitor засекает 10 ms. Если за 10ms syscall не завершается, он дает команду на выполнение Handoff.

## MPN модель
M тредов, P процессоров и N горутин.

## Network Poller
Когда горутина совершает syscall мы переводим ее в состояние waiting, регистрируем ее в NetPoller, а процессор освобождается. Ждущие горутины могут находится в нетполлере сколько нужно, и это не замедляет программу.

Если горутины долго простаивают в NetPoller, то Sysmon сам перемещает их в GRQ.

Если горутина работает дольше 10 ms sysmon присваивает ей флаг и во время блокирующих операций горутина сама уйдет спать -> в го планировщик кооперативный, но с элементами вытесняющего.

## Go v1.14
Если горутина работает дольше 10ms, то посылается ОС сигнал SIGURG, который прерывает выполнение горутины.